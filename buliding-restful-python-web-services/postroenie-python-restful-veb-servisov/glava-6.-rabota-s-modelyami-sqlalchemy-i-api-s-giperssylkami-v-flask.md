# Глава 6. Работа с моделями, SQLAlchemy и API с гиперссылками в Flask

В этой главе мы расширим возможности RESTful API, которые мы начали в предыдущей главе. Мы будем использовать **SQLAlchemy** в качестве нашей ORM для работы с базой данных **PostgreSQL**, и мы воспользуемся расширенными функциями, включенными в **Flask** и **Flask-RESTful**, которые позволят нам легко организовать код для сложных API, таких как модели и схемы blueprints. В этой главе мы будем:

* Разработка RESTful API для взаимодействия с базой данных PostgreSQL.
* Понимание задач, выполняемых каждым методом HTTP
* Установка пакетов, чтобы упростить наши общие задачи
* Создание и настройка базы данных
* Напишите код для моделей с их отношениями
* Использование схемы для проверки, сериализации и десериализации моделей
* Комбинация схем с ресурсной маршрутизацией
* Регистрация схемы и запуск миграции
* Создание и извлечение связанных ресурсов

## Разработка RESTful API для взаимодействия с базой данных PostgreSQL

До сих пор наш RESTful API выполнял операции **CRUD** с простым словарем, выступавшим в роли хранилища данных. Теперь мы хотим создать более сложный RESTful API с Flask RESTful для взаимодействия с моделью базы данных, которая должна позволять нам работать с сообщениями, сгруппированными в категории сообщений. В нашем предыдущем RESTful API мы использовали строковый атрибут, чтобы указать категорию сообщения для сообщения. В этом случае мы хотим иметь возможность легко получить все сообщения, принадлежащие к определенной категории сообщений, и, следовательно, у нас будет связь между сообщением и категорией сообщений.

Мы должны иметь возможность выполнять операции CRUD с различными связанными ресурсами и коллекциями ресурсов. В следующем списке перечислены ресурсы и имя класса, которые мы создадим для представления модели:

* Категории сообщений (модель Category)
* Сообщения (модель Message)

Категория сообщения (**Category**) просто требует целочисленного имени, а для сообщения (**Message**) нам нужны следующие данные:

* Целочисленный идентификатор
* Внешний ключ к категории сообщений (Category)
* Строковое сообщение
* Продолжительность в секундах, указывающая время, в течение которого сообщение должно быть напечатано на OLED-дисплее.
* Дата и время создания. Временная метка будет добавлена автоматически при добавлении нового сообщения в коллекцию
* Целочисленный счетчик, указывающий, сколько раз сообщение было напечатано на OLED-дисплее.
* Логическое значение, указывающее, было ли сообщение напечатано хотя бы один раз на OLED-дисплее.

{% hint style="info" %}
**СОВЕТ**

Мы воспользуемся преимуществами множества пакетов, связанных с Flask RESTful и SQLAlchemy, которые упрощают сериализацию и десериализацию данных, выполняют проверки и интегрируют SQLAlchemy с Flask и Flask RESTful.
{% endhint %}

## Понимание задач, выполняемых каждым методом HTTP

В следующей таблице показаны запросы HTTP, область действия и семантика методов, которые должен поддерживать наш новый API. Каждый метод состоит из запроса HTTP, области действия, и все методы имеют четко определенные значения для всех ресурсов и коллекций:

| HTTP запрос | Область действия              | Семантика                                                                                                                                                                                                                                                                                                                                                                                                            |
| ----------- | ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GET         | Коллекция категорий сообщений | Получает все сохраненные категории сообщений в коллекции и возвращает их, отсортированные по имени в порядке возрастания. Каждая категория должна включать полный URL-адрес ресурса. Каждая категория должна включать список со всеми сведениями о сообщениях, принадлежащих этой категории. Сообщения не должны включать категорию, чтобы избежать повторения данных.                                               |
| GET         | Категория сообщения           | Получает одну категорию сообщений. Категория должна включать ту же информацию, что и для каждой категории, когда мы извлекаем набор категорий сообщений.                                                                                                                                                                                                                                                             |
| POST        | Коллекция категорий сообщений | Создает новую категорию сообщений в коллекции.                                                                                                                                                                                                                                                                                                                                                                       |
| PATCH       | Категория сообщения           | Обновляет имя существующей категории сообщений.                                                                                                                                                                                                                                                                                                                                                                      |
| DELETE      | Категория сообщения           | Удаляет существующую категорию сообщений.                                                                                                                                                                                                                                                                                                                                                                            |
| GET         | Коллекция сообщений           | Получает все сохраненные сообщения в коллекции, отсортированные по их сообщениям в порядке возрастания. Каждое сообщение должно содержать сведения о категории сообщений, включая полный URL-адрес для доступа к соответствующему ресурсу. Сведения о категории сообщений не обязательно должны включать сообщения, принадлежащие этой категории. Сообщение должно содержать полный URL-адрес для доступа к ресурсу. |
| GET         | Сообщение                     | Получает одно сообщение. Сообщение должно включать ту же информацию, которая объясняется для каждого сообщения, когда мы извлекаем набор сообщений.                                                                                                                                                                                                                                                                  |
| POST        | Коллекция сообщений           | Создает новое сообщение в коллекции.                                                                                                                                                                                                                                                                                                                                                                                 |
| PATCH       | Сообщение                     | Обновляет любое из следующих полей существующего сообщения: _message_, _duration_, _printed\_times_ и _printed\_once_.                                                                                                                                                                                                                                                                                               |
| DELETE      | Сообщение                     | Удаляет существующее сообщение.                                                                                                                                                                                                                                                                                                                                                                                      |

Кроме того, наш RESTful API должен поддерживать метод **OPTIONS** для всех ресурсов и коллекции ресурсов. Мы будем использовать **SQLAlchemy** в качестве нашей ORM и будем работать с базой данных **PostgreSQL**. Однако, если вы не хотите тратить время на установку PostgreSQL, вы можете использовать любую другую базу данных, поддерживаемую SQLAlchemy, например **MySQL**. Если вам нужна самая простая база данных, вы можете работать с **SQLite**.

В предыдущей таблице указано множество методов и областей. В следующем списке перечислены URI для каждой области, упомянутой в предыдущей таблице, где `{id}` необходимо заменить числовым идентификатором или первичным ключом ресурса. Как и в предыдущем примере, мы хотим, чтобы наш API отличал коллекции от одного ресурса коллекции в URL-адресах. Когда мы ссылаемся на коллекцию, мы **будем** использовать косую черту (`/`) в качестве последнего символа для URL-адреса, а когда мы ссылаемся на один ресурс коллекции, мы **не будем** использовать косую черту (`/`) в качестве последнего символа для URL-адреса. URL-адрес:

* Коллекция категорий сообщений: `/categories/`
* Категория сообщения: `/category/{id}`
* Коллекция сообщений: `/messages/`
* Сообщение: `/message/{id}`

Предположим, что `http://localhost:5000/api/` — это URL-адрес API, работающего на сервере разработки **Flask**. Мы должны составить и отправить HTTP-запрос со следующей командой HTTP (**GET**) и URL-адресом запроса (`http://localhost:5000/api/categories/`), чтобы получить все сохраненные категории сообщений в коллекции. Каждая категория будет включать в себя список со всеми сообщениями, которые принадлежат к категории.

```bash
GET http://localhost:5000/api/categories/
```

## Установка пакетов для упрощения наших общих задач

Убедитесь, что вы вышли из сервера разработки **Flask**. Помните, что вам просто нужно нажать _**Ctrl + C**_ в окне терминала или командной строки, в котором он запущен. Теперь мы установим много дополнительных пакетов. Убедитесь, что вы активировали виртуальную среду, которую мы создали в предыдущей главе и назвали **Flask01**. Если вы создали новую виртуальную среду для работы с этим примером или загрузили образец кода для книги, убедитесь, что вы установили пакеты, которые мы использовали в предыдущем примере.

После того, как вы активируете виртуальную среду, пришло время запустить команды, которые будут одинаковыми для macOS, Linux или Windows. Мы можем установить все необходимые пакеты с помощью **pip** с помощью одной команды. Однако мы будем запускать независимые команды, чтобы упростить обнаружение любых проблем в случае сбоя конкретной установки.

Теперь мы должны запустить следующую команду, чтобы установить **Flask-SQLAlchemy** с pip. Flask-SQLAlchemy добавляет поддержку SQLAlchemy ORM в приложения Flask. Это расширение упрощает выполнение общих задач SQLAlchemy в приложении Flask. SQLAlchemy является зависимостью для Flask-SQLAlchemy, поэтому pip также установит его автоматически:

```bash
pip install Flask-SQLAlchemy
```

В последних строках вывода будут указаны все пакеты, которые были успешно установлены, включая **SQLAlchemy** и **Flask-SQLAlchemy**:

```bash
Installing collected packages: SQLAlchemy, Flask-SQLAlchemy
  Running setup.py install for SQLAlchemy
  Running setup.py install for Flask-SQLAlchemy
Successfully installed Flask-SQLAlchemy-2.1 SQLAlchemy-1.0.14
```

Выполните следующую команду, чтобы установить **Flask-Migrate** с помощью **pip**. Flask-Migrate использует пакет **Alembic** для обработки миграции базы данных SQLAlchemy для приложений Flask. Мы будем использовать Flask-Migrate для настройки нашей базы данных **PostgreSQL**. **Flask-Script** является одной из зависимостей для Flask-Migrate, поэтому pip установит его автоматически. Flask-Script добавляет поддержку написания внешних сценариев в Flask, включая сценарии для настройки базы данных.

```bash
pip install Flask-Migrate
```

В последних строках вывода будут указаны все пакеты, которые были успешно установлены, включая **Flask-Migrate** и **Flask-Script**. Другие установленные пакеты являются дополнительными зависимостями:

```bash
Installing collected packages: Mako, python-editor, alembic, Flask-Script,
Flask-Migrate
  Running setup.py install for Mako
  Running setup.py install for python-editor
  Running setup.py install for alembic
  Running setup.py install for Flask-Script
  Running setup.py install for Flask-Migrate
Successfully installed Flask-Migrate-2.0.0 Flask-Script-2.0.5 Mako-1.0.4
alembic-0.8.7 python-editor-1.0.1
```

Выполните следующую команду, чтобы установить **marshmallow** с помощью **pip**. Marshmallow — это облегченная библиотека для преобразования сложных типов данных в собственные типы данных Python и обратно. Marshmallow предоставляет схемы, которые мы можем использовать для проверки входных данных, десериализации входных данных в объекты уровня приложения и сериализации объектов уровня приложения в примитивные типы Python:

```bash
pip install marshmallow
```

Последние строки вывода укажут, что **marshmallow** успешно установлен:

```bash
Installing collected packages: marshmallow
Successfully installed marshmallow-2.9.1
```

Выполните следующую команду, чтобы установить **Marshmallow-sqlalchemy** с помощью **pip**. Marshmallow-sqlalchemy обеспечивает интеграцию SQLAlchemy с ранее установленной облегченной библиотекой проверки, сериализации и десериализации зефира:

```bash
pip install marshmallow-sqlalchemy
```

Последние строки вывода будут означать, что **marshmallow-sqlalchemy** успешно установлен:

```bash
Installing collected packages: marshmallow-sqlalchemy
Successfully installed marshmallow-sqlalchemy-0.10.0
```

Наконец, выполните следующую команду, чтобы установить **Flask-Marshmallow** с помощью **pip**. Flask-Marshmallow интегрирует ранее установленную библиотеку marshmallow с приложениями Flask и упрощает создание полей URL и гиперссылок:

```bash
pip install Flask-Marshmallow
```

Последние строки вывода будут означать, что **Flask-Marshmallow** успешно установлен:

```bash
Installing collected packages: Flask-Marshmallow
Successfully installed Flask-Marshmallow-0.7.0
```

## Создание и настройка базы данных

Теперь мы создадим базу данных **PostgreSQL**, которую будем использовать в качестве репозитория для нашего API. Вам нужно будет загрузить и установить базу данных PostgreSQL, если вы еще не используете ее на своем компьютере или на сервере разработки. Вы можете загрузить и установить эту систему управления базами данных с ее веб-страницы: [http://www.postgresql.org](https://www.postgresql.org). Если вы работаете с macOS, **Postgres.app** предоставляет действительно простой способ установки и использования PostgreSQL в этой операционной системе: [http://postgresapp.com](https://postgresapp.com):

{% hint style="info" %}
**СОВЕТ**

Вы должны убедиться, что папка **bin** PostgreSQL включена в переменную окружения **PATH**. Вы должны иметь возможность запускать утилиту командной строки **psql** из текущего терминала или командной строки. Если папка не указана в PATH, вы получите сообщение об ошибке, указывающее, что файл **pg\_config** не может быть найден при попытке установить пакет **psycopg2**. Кроме того, вам нужно будет указать полный путь к каждому инструменту командной строки PostgreSQL, который мы будем использовать на следующих шагах.
{% endhint %}

Мы будем использовать инструменты командной строки PostgreSQL для создания новой базы данных с именем **messages**. Если у вас уже есть база данных PostgreSQL с таким именем, убедитесь, что вы используете другое имя во всех командах и конфигурациях. Вы можете выполнить ту же задачу с помощью любого графического инструмента **PostgreSQL**. Если вы разрабатываете в Linux, необходимо запускать команды от имени пользователя **postgres**. Выполните следующую команду в macOS или Windows, чтобы создать новую базу данных с именем **messages**. Обратите внимание, что команда не будет производить никакого вывода:

```bash
createdb messages
```

В Linux выполните следующую команду, чтобы использовать пользователя **postgres**:

```bash
sudo -u postgres createdb messages
```

Теперь мы будем использовать инструмент командной строки **psql** для запуска некоторых операторов **SQL**, чтобы создать конкретного пользователя, которого мы будем использовать во **Flask**, и назначить ему необходимые роли. В macOS или Windows выполните следующую команду, чтобы запустить **psql**:

```powershell
psql
```

В Linux выполните следующую команду, чтобы использовать пользователя **postgres**:

```bash
sudo -u psql
```

Затем выполните следующие операторы SQL и, наконец, введите `\q`, чтобы выйти из инструмента командной строки **psql**. Замените **user\_name** на желаемое имя пользователя для использования в новой базе данных и пароль на выбранный вами пароль. Мы будем использовать имя пользователя и пароль в конфигурации **Flask**. Вам не нужно выполнять эти шаги, если вы уже работаете с конкретным пользователем в PostgreSQL и уже предоставили права доступа к базе данных для этого пользователя. Вы увидите вывод, указывающий, что разрешение было предоставлено.

```sql
CREATE ROLE user_name WITH LOGIN PASSWORD 'password';
GRANT ALL PRIVILEGES ON DATABASE messages TO user_name;
ALTER USER user_name CREATEDB;
\q
```

Необходимо установить пакет **Psycopg 2** (psycopg2). Этот пакет представляет собой адаптер базы данных **Python-PostgreSQL**, и SQLAlchemy будет использовать его для взаимодействия с нашей недавно созданной базой данных PostgreSQL.

После того, как мы убедились, что папка **bin** PostgreSQL включена в переменную среды **PATH**, нам просто нужно выполнить следующую команду для установки этого пакета:

```bash
pip install psycopg2
```

Последние строки вывода укажут, что пакет **psycopg2** успешно установлен:

```bash
Collecting psycopg2
Installing collected packages: psycopg2
  Running setup.py install for psycopg2
Successfully installed psycopg2-2.6.2
```

Если вы используете ту же виртуальную среду, которую мы создали для предыдущего примера, папка API уже существует. Если вы создаете новую виртуальную среду, создайте папку с именем **api** в корневой папке созданной виртуальной среды.

Создайте новый файл **config.py** в папке **api**. В следующих строках показан код, объявляющий переменные, определяющие конфигурацию Flask и SQLAlchemy. Переменная **SQL\_ALCHEMY\_DATABASE\_URI** генерирует URI SQLAlchemy для базы данных **PostgreSQL**.

Убедитесь, что вы указали желаемое имя базы данных в значении для **DB\_NAME** и что вы настроили **user**, **password**, **host** и **port** в соответствии с вашей конфигурацией **PostgreSQL**. Если вы выполнили предыдущие шаги, используйте настройки, указанные в этих шагах. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
import os

basedir = os.path.abspath(os.path.dirname(__file__))
DEBUG = True
PORT = 5000
HOST = "127.0.0.1"
SQLALCHEMY_ECHO = False
SQLALCHEMY_TRACK_MODIFICATIONS = True
SQLALCHEMY_DATABASE_URI = "postgresql://{DB_USER}:{DB_PASS}@{DB_ADDR}/{DB_NAME}".format(
    DB_USER="user_name", DB_PASS="password",
    DB_ADDR="127.0.0.1", DB_NAME="messages")
SQLALCHEMY_MIGRATE_REPO = os.path.join(basedir, 'db_repository')
```

Мы укажем модуль, созданный ранее, в качестве аргумента функции, которая создаст приложение **Flask**. Таким образом, у нас есть один модуль, который указывает все значения для различных переменных конфигурации, и другой модуль, который создает приложение Flask. Мы создадим фабрику приложений Flask в качестве последнего шага к нашему новому API.

## Создание моделей с их отношениями

Теперь мы создадим модели, которые мы можем использовать для представления и сохранения категорий сообщений, сообщений и их взаимосвязей. Откройте файл `api/models.py` и замените его содержимое следующим кодом. Строки, которые объявляют поля, относящиеся к другим моделям, выделены в листинге кода. Если вы создали новую виртуальную среду, создайте новый файл **models.py** в папке **api**. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```
from marshmallow import Schema, fields, pre_load
from marshmallow import validate
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow

db = SQLAlchemy()
ma = Marshmallow()

class AddUpdateDelete():
    def add(self, resource):
        db.session.add(resource)
        return db.session.commit()

    def update(self):
        return db.session.commit()

    def delete(self, resource):
        db.session.delete(resource)
        return db.session.commit()

class Message(db.Model, AddUpdateDelete):
    id = db.Column(db.Integer, primary_key=True)
    message = db.Column(db.String(250), unique=True, nullable=False)
    duration = db.Column(db.Integer, nullable=False)
    creation_date = db.Column(
        db.TIMESTAMP,
        server_default=db.func.current_timestamp(),
        nullable=False)
    category_id = db.Column(
        db.Integer,
        db.ForeignKey('category.id', ondelete='CASCADE'),
        nullable=False)
    category = db.relationship(
        'Category',
        backref=db.backref('messages', lazy='dynamic' , order_by='Message.message'))
    printed_times = db.Column(db.Integer, nullable=False, server_default='0')
    printed_once = db.Column(db.Boolean, nullable=False, server_default='false')

    def __init__(self, message, duration, category):
        self.message = message
        self.duration = duration
        self.category = category

class Category(db.Model, AddUpdateDelete):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(150), unique=True, nullable=False)

    def __init__(self, name):
        self.name = name
```

Во-первых, код создает экземпляр класса `flask_sqlalchemy.SQLAlchemy` с именем **db**. Этот экземпляр позволит нам управлять интеграцией **SQLAlchemy** для нашего приложения **Flask**. Кроме того, экземпляр предоставит доступ ко всем функциям и классам SQLAlchemy.

Затем код создает экземпляр класса  с именем **ma**. Очень важно создать экземпляр `flask_sqlalchemy.SQLAlchemy` перед экземпляром **Marshmallow**, поэтому в этом случае порядок имеет значение. **Marshmallow** — это класс-оболочка, который интегрирует Mashmallow с приложением **Flask**. Экземпляр с именем **ma** предоставит доступ к классу **Schema**, полям, определенным в `marshmallow.fields`, и полям, специфичным для **Flask**, объявленным в `flask_marshmallow.fields`. Мы будем использовать их позже, когда будем объявлять схемы, связанные с нашими моделями.

Код создает класс **AddUpdateDelete**, который объявляет следующие три метода для добавления, обновления и удаления ресурса через сеансы **SQLAlchemy**:

* **add**: этот метод получает добавляемый объект в качестве аргумента ресурса и вызывает метод `db.session.add` с полученным ресурсом в качестве аргумента для создания объекта в базовой базе данных. Наконец, код фиксирует сеанс.
* **update**: этот метод просто фиксирует сеанс, чтобы сохранить изменения, внесенные в объекты в базовой базе данных.
* **delete**: этот метод получает удаляемый объект в качестве аргумента ресурса и вызывает метод `db.session.delete` с полученным ресурсом в качестве аргумента для удаления объекта из базовой базы данных. Наконец, код фиксирует сеанс.

В коде объявляются следующие две модели, а именно два класса, как подклассы классов **db.Model** и **AddUpdateDelete**:

* Message
* Category

Мы указали типы полей, максимальную длину и значения по умолчанию для многих атрибутов. Атрибуты, представляющие поля без какой-либо связи, являются экземплярами класса **db.Column**. Обе модели объявляют атрибут **id** и указывают значение `True` для аргумента **primary\_key**, чтобы указать, что это первичный ключ. SQLAlchemy будет использовать данные для создания необходимых таблиц в базе данных PostgreSQL.

Модель **Message** объявляет поле категории **category** следующей строкой:

```python
category = db.relationship(
    'Category',
    backref=db.backref('messages', lazy='dynamic', order_by='Message.message')
)
```

Предыдущая строка использует функцию **db.relationship**, чтобы установить связь «многие к одному» с моделью категорий **Category**. Аргумент **backref** задает вызов функции **db.backref** с `'messages'` в качестве первого значения, указывающего имя, используемое _**для отношения от связанного объекта категории обратно к объекту сообщения**_. Аргумент **order\_by** указывает `«Message.message»`, потому что мы хотим, чтобы сообщения для каждой категории сортировались по значению поля сообщения в порядке возрастания.

Обе модели объявляют конструктор, то есть метод **\_\_init\_\_**. Этот конструктор для модели **Message** получает множество аргументов и использует их для инициализации атрибутов с одинаковыми именами: message, duration и category. Конструктор модели категории получает аргумент name и использует его для инициализации атрибута с тем же именем.

## Создание схем для проверки, сериализации и десериализации моделей

Теперь мы создадим схемы **Flask-Marshmallow**, которые будем использовать для проверки, сериализации и десериализации ранее объявленных моделей категорий и сообщений и их взаимосвязей. Откройте файл `api/models.py` и добавьте следующий код после существующих строк. Строки, которые объявляют поля, относящиеся к другим схемам, выделены в листинге кода. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
class CategorySchema(ma.Schema):
    id = fields.Integer(dump_only=True)
    name = fields.String(required=True, validate=validate.Length(3))
    url = ma.URLFor('api.categoryresource', id='<id>', _external=True)
    messages = fields.Nested('MessageSchema', many=True, exclude=('category',))

class MessageSchema(ma.Schema):
    id = fields.Integer(dump_only=True)
    message = fields.String(required=True, validate=validate.Length(1))
    duration = fields.Integer()
    creation_date = fields.DateTime()
    category = fields.Nested(
        CategorySchema, only=['id', 'url', 'name'], required=True
    )
    printed_times = fields.Integer()
    printed_once = fields.Boolean()
    url = ma.URLFor('api.messageresource', id='<id>', _external=True)

    @pre_load
    def process_category(self, data):
        category = data.get('category')
        if category:
            if isinstance(category, dict):
                category_name = category.get('name')
            else:
                category_name = category
            category_dict = dict(name=category_name)
        else:
            category_dict = {}
        data['category'] = category_dict
        return data
```

Код объявляет следующие две схемы, а именно два подкласса класса **ma.Schema**:

* CategorySchema
* MessageSchema

Мы не используем функции **Flask-Marshmallow**, которые позволяют нам автоматически определять подходящий тип для каждого атрибута на основе полей, объявленных в модели, поскольку мы хотим использовать определенные параметры для каждого поля. Мы объявляем атрибуты, представляющие поля, как экземпляры соответствующего класса, объявленного в модуле **marshmallow.fields**. Всякий раз, когда мы указываем значение `True` для аргумента **dump\_only**, это означает, что мы хотим, чтобы поле было _**доступно только для чтения**_. Например, мы не сможем указать значение для поля **id** ни в одной из схем. Значение для этого поля будет автоматически сгенерировано первичным ключом автоинкремента в базе данных.

Класс **CategorySchema** объявляет атрибут **name** как экземпляр `fields.String`. Аргумент **required** имеет значение `True`, чтобы указать, что поле не может быть пустой строкой. Аргументу проверки **validate** присвоено значение `validate.Length(3)`, чтобы указать, что поле должно иметь минимальную длину 3 символа.

Класс объявляет поле URL следующей строкой:

```python
url = ma.URLFor('api.categoryresource', id='<id>', _external=True)
```

Атрибут **url** является экземпляром класса **ma.URLFor**, и это поле выводит полный URL-адрес ресурса, то есть ресурса категории сообщений. Первый аргумент — это имя конечной точки Flask — `'api.categoryresource'`. Позже мы создадим класс **CategoryResource**, и класс **URLFor** будет использовать его для создания URL-адреса. Аргумент **id** указывает `'<id>'`, потому что мы хотим, чтобы идентификатор извлекался из сериализуемого объекта. Строка идентификатора, заключенная в символы меньше `(<)` и больше `(>)`, указывает, что мы хотим, чтобы _**поле было извлечено из объекта**_, который должен быть сериализован. Атрибут **\_external** имеет значение `True`, потому что мы хотим сгенерировать полный URL-адрес для ресурса. Таким образом, каждый раз, когда мы сериализуем категорию, она будет включать полный URL-адрес ресурса в ключ URL-адреса **url**.

{% hint style="info" %}
**СОВЕТ**

В этом случае мы используем наш небезопасный API за **HTTP**. В случае, если наш API настроен на **HTTPS**, мы должны установить аргумент **\_scheme** равным `«https»` при создании экземпляра **ma.URLFor**.
{% endhint %}

Класс объявляет поле сообщений **messages** следующей строкой:

```python
messages = fields.Nested('MessageSchema', many=True, exclude=('category',))
```

Атрибут **messages** является экземпляром класса `marshmallow.fields.Nested`, и в это поле будет вложена коллекция **Schema**, поэтому мы указываем `True` для аргумента **many**. Первый аргумент указывает имя для вложенного класса **Schema** в виде строки. Мы объявляем класс **MessageSchema** после определения класса **CategorySchema**. Таким образом, мы указываем имя класса **Schema** в виде строки вместо использования типа, который мы еще не определили.

Фактически у нас получится два объекта, которые вложены друг в друга, то есть мы создадим двустороннюю вложенность между категориями и сообщениями. Мы используем параметр **exclude** с кортежем строки, чтобы указать, что мы хотим, чтобы поле категории было исключено из полей, стерилизуемых для каждого сообщения. Таким образом, мы можем избежать бесконечной рекурсии, потому что включение поля категории приведет к сериализации всех сообщений, связанных с категорией.

Когда мы объявили модель **Message**, мы использовали функцию **db.relationship**, чтобы обеспечить связь «многие к одному» с моделью **Category**. Аргумент **backref** задает вызов функции **db.backref** с `'messages'` в качестве первого значения, указывающего имя, используемое для отношения от связанного объекта категории обратно к объекту сообщения. С помощью ранее объясненной строки мы создали поля сообщений, использующие то же имя, которое мы указали для функции **db.backref**.

Класс **MessageSchema** объявляет атрибут сообщения **message** как экземпляр **fields.String**. Аргумент **required** имеет значение `True`, чтобы указать, что поле не может быть пустой строкой. Аргументу проверки **validate** присвоено значение `validate.Length(1`), чтобы указать, что поле должно иметь минимальную длину 1 символ. В классе объявляются поля «**duration**», «**creation\_date**», «**print\_times**» и «**print\_once**» с соответствующими классами на основе типов, которые мы использовали в модели сообщений.

Класс объявляет поле категории **category** следующей строкой:

```python
category = fields.Nested(
    CategorySchema,
    only=['id', 'url', 'name'],
    required=True
)
```

Атрибут **category** является экземпляром класса `marshmallow.fields.Nested`, и это поле будет вкладывать одну **CategorySchema**. Мы указываем `True` для аргумента **required**, потому что сообщение должно принадлежать к категории. Первый аргумент указывает имя для вложенного класса **Schema**. Мы уже объявили класс **CategorySchema**, поэтому указываем **CategorySchema** в качестве значения для первого аргумента. Мы используем параметр **only** со списком строк, чтобы указать имена полей, которые мы хотим включить при сериализации вложенной схемы категорий. Мы хотим, чтобы поля **id**, **url** и **name** были включены. Мы не указываем поле сообщений **messages**, потому что не хотим, чтобы категория сериализовала список принадлежащих ей сообщений.

Класс объявляет поле **url** следующей строкой:

```python
url = ma.URLFor('api.messageresource', id='<id>', _external=True)
```

Атрибут **url** является экземпляром класса **ma.URLFor**, и это поле выводит полный URL-адрес ресурса, то есть ресурса сообщения. Первый аргумент — это имя конечной точки Flask: `«api.messageresource»`. Позже мы создадим класс **MessageResource**, и класс **URLFor** будет использовать его для создания URL-адреса. Аргумент **id** указывает `'<id>'`, потому что мы хотим, чтобы идентификатор извлекался из сериализуемого объекта. Атрибут **\_external** имеет значение `True`, потому что мы хотим сгенерировать полный URL-адрес для ресурса. Таким образом, каждый раз, когда мы сериализуем сообщение, оно будет включать полный URL-адрес ресурса в ключ URL-адреса **url**.

Класс **MessageSchema** объявляет метод **process\_category**, который использует декоратор `@pre_load`, в частности, `marshmallow.pre_load`. Этот декоратор регистрирует метод для вызова перед десериализацией объекта. Таким образом, прежде чем **Marshmallow** десериализует сообщение, будет выполнен метод **process\_category**.

Метод получает данные для десериализации в аргументе **data** и возвращает обработанные данные. Когда мы получаем запрос на отправку нового сообщения **POST**, имя категории может быть указано в ключе с именем `'category'`. Если категория с указанным именем существует, мы будем использовать существующую категорию как ту, которая связана с новым сообщением. Если категория с указанным именем не существует, мы создадим новую категорию, а затем будем использовать эту новую категорию как ту, которая связана с новым сообщением. Таким образом, мы облегчаем пользователю создание новых сообщений.

Аргумент **data** может иметь имя категории, указанное в виде строки для ключа `'category'`. Однако в других случаях ключ `'category'` будет включать пары «ключ-значение» с именем поля и значениями поля для существующей категории. Код в методе **process\_category** проверяет значение ключа `'category'` и возвращает словарь с соответствующими данными, чтобы убедиться, что мы можем десериализовать категорию с соответствующими парами «ключ-значение», независимо от различий входящих данных. Наконец, метод возвращает обработанный словарь. Мы углубимся в работу, выполняемую методом **process\_category**, позже, когда начнем составлять и отправлять HTTP-запросы к API.

## Сочетание схем blueprint с маршрутизацией ресурсов

Теперь мы создадим ресурсы, которые составят наши основные строительные блоки для RESTful API. Сначала мы создадим несколько экземпляров, которые будем использовать в разных ресурсах. Затем мы создадим класс **MessageResource**, который будем использовать для представления ресурса сообщения. Создайте новый файл **views.py** в папке **api** и добавьте следующие строки. Файл кода для примера включен в папку `restful_python_chapter_06_01`, как показано ниже:

```python
from flask import Blueprint, request, jsonify, make_response
from flask_restful import Api, Resource
from models import db, Category, CategorySchema, Message, MessageSchema
from sqlalchemy.exc import SQLAlchemyError
import status

api_bp = Blueprint('api', __name__)
category_schema = CategorySchema()
message_schema = MessageSchema()
api = Api(api_bp)

class MessageResource(Resource):
    def get(self, id):
        message = Message.query.get_or_404(id)
        result = message_schema.dump(message).data
        return result

    def patch(self, id):
        message = Message.query.get_or_404(id)
        message_dict = request.get_json(force=True)
        if 'message' in message_dict:
            message.message = message_dict['message']
        if 'duration' in message_dict:
            message.duration = message_dict['duration']
        if 'printed_times' in message_dict:
            message.printed_times = message_dict['printed_times']
        if 'printed_once' in message_dict:
            message.printed_once = message_dict['printed_once']
        dumped_message, dump_errors = message_schema.dump(message)
        if dump_errors:
            return dump_errors, status.HTTP_400_BAD_REQUEST
        validate_errors = message_schema.validate(dumped_message)
        #errors = message_schema.validate(data)
        if validate_errors:
            return validate_errors, status.HTTP_400_BAD_REQUEST
        try:
            message.update()
            return self.get(id)
        except SQLAlchemyError as e:
            db.session.rollback()
            resp = jsonify({"error": str(e)})
            return resp, status.HTTP_400_BAD_REQUEST

    def delete(self, id):
        message = Message.query.get_or_404(id)
        try:
            delete = message.delete(message)
            response = make_response()
            return response, status.HTTP_204_NO_CONTENT
        except SQLAlchemyError as e:
            db.session.rollback()
            resp = jsonify({"error": str(e)})
            return resp, status.HTTP_401_UNAUTHORIZED
```

Первые строки объявляют импорт и создают следующие экземпляры, которые мы будем использовать в разных классах:

* **api\_bp**: это экземпляр класса **flask.Blueprint**, который позволит нам включить приложение Flask в этот план. Первый аргумент указывает префикс URL-адреса, на котором мы хотим зарегистрировать схему: `'api'`.
* **category\_schema**: это экземпляр класса **CategorySchema**, который мы объявили в модуле **models.py**. Мы будем использовать **category\_schema** для проверки, сериализации и десериализации категорий.
* **message\_schema**: это экземпляр класса **MessageSchema**, который мы объявили в модуле **models.py**. Мы будем использовать **message\_schema** для проверки, сериализации и десериализации категорий.
* **api**: это экземпляр класса **flask\_restful.Api**, представляющий основную точку входа для приложения. Мы передаем ранее созданный экземпляр **flask.Blueprint** с именем **api\_bp** в качестве аргумента, чтобы связать API с Blueprint.

Класс **MessageResource** является подклассом **flask\_restful.Resource** и объявляет следующие три метода, которые будут вызываться при поступлении одноименного HTTP-метода в качестве запроса на представленный ресурс:

* **get**: этот метод получает идентификатор сообщения, которое необходимо получить в аргументе идентификатора. Код вызывает метод `Message.query.get_or_404`, чтобы вернуть статус HTTP **404 Not Found**, если в базовой базе данных нет сообщения с запрошенным идентификатором. Если сообщение существует, код вызывает метод `message_schema.dump` с полученным сообщением в качестве аргумента, чтобы использовать экземпляр **MessageSchema** для сериализации экземпляра **Message**, идентификатор которого соответствует указанному идентификатору. Метод дампа принимает экземпляр **Message** и применяет фильтрацию полей и форматирование вывода, указанные в классе **MessageSchema**. Код возвращает атрибут **data** результата, возвращенного методом дампа, то есть сериализованное сообщение в формате **JSON** в качестве тела с кодом состояния HTTP **200 OK** по умолчанию.
* **delete**: этот метод получает идентификатор сообщения, которое необходимо удалить, в аргументе идентификатора. Код вызывает метод `Message.query.get_or_404`, чтобы вернуть статус HTTP **404 Not Found**, если в базовой базе данных нет сообщения с запрошенным идентификатором. Если сообщение существует, код вызывает метод **message.delete** с полученным сообщением в качестве аргумента, чтобы использовать экземпляр **Message** для удаления самого себя из базы данных. Затем код возвращает пустое тело ответа и код состояния **204 No Content**.
* **patch**: этот метод получает идентификатор сообщения, которое должно быть обновлено или исправлено, в аргументе **id**. Код вызывает метод `Message.query.get_or_404`, чтобы вернуть статус HTTP **404 Not Found**, если в базовой базе данных нет сообщения с запрошенным идентификатором. Если сообщение существует, код вызывает метод  для получения пар ключ-значение, полученных в качестве аргументов запроса. Код обновляет определенные атрибуты, если они имеют новые значения в словаре **message\_dict** в экземпляре **Message**: **message**. Затем код вызывает метод `message_schema.dump` для извлечения любых ошибок, возникших при сериализации обновленного сообщения. В случае возникновения ошибок код возвращает ошибки и статус HTTP **400 Bad Request**. Если сериализация не привела к ошибкам, код вызывает метод `message_schema.validate` для получения любых ошибок, возникших при проверке обновленного сообщения. В случае ошибок проверки код возвращает ошибки проверки и статус HTTP **400 Bad Request**. Если проверка прошла успешно, код вызывает метод обновления для экземпляра **Message**, чтобы сохранить изменения в базе данных, и возвращает результаты вызова ранее объясненного метода `self.get` с идентификатором обновленного сообщения в качестве аргумента. Таким образом, метод возвращает сериализованное обновленное сообщение в формате **JSON** в качестве тела с кодом состояния HTTP **200 OK** по умолчанию.

Теперь мы создадим класс **MessageListResource**, который будем использовать для представления коллекции сообщений. Откройте ранее созданный файл `api/views.py` и добавьте следующие строки. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
class MessageListResource(Resource):
    def get(self):
        messages = Message.query.all()
        result = message_schema.dump(messages, many=True).data
        return result

    def post(self):
        request_dict = request.get_json()
        if not request_dict:
            response = {'message': 'No input data provided'}
            return response, status.HTTP_400_BAD_REQUEST
        errors = message_schema.validate(request_dict)
        if errors:
            return errors, status.HTTP_400_BAD_REQUEST
        try:
            category_name = request_dict['category']['name']
            category = Category.query.filter_by(name=category_name).first()
            if category is None:
                # Создание новой категории Category
                category = Category(name=category_name)
                db.session.add(category)
            # Теперь, когда мы уверены, что у нас есть категория,
            # создаем новое сообщение.
            message = Message(
                message=request_dict['message'],
                duration=request_dict['duration'],
                category=category)
            message.add(message)
            query = Message.query.get(message.id)
            result = message_schema.dump(query).data
            return result, status.HTTP_201_CREATED
        except SQLAlchemyError as e:
            db.session.rollback()
            resp = jsonify({"error": str(e)})
            return resp, status.HTTP_400_BAD_REQUEST
```

Класс **MessageListResource** является подклассом `flask_restful.Resource` и объявляет следующие два метода, которые будут вызываться при поступлении HTTP-метода с тем же именем в качестве запроса на представленный ресурс:

* **get**: этот метод возвращает список со всеми экземплярами **Message**, сохраненными в базе данных. Во-первых, код вызывает метод `Message.query.all` для получения всех экземпляров **Message**, сохраненных в базе данных. Затем код вызывает метод `message_schema.dump` с извлеченными сообщениями и аргументом **many**, для которого задано значение `True`, чтобы сериализовать итерируемую коллекцию объектов. Метод дампа возьмет каждый экземпляр **Message**, полученный из базы данных, и применит фильтрацию полей и форматирование вывода, указанные в классе **MessageSchema**. Код возвращает атрибут данных результата, возвращенного методом дампа, то есть сериализованные сообщения в формате **JSON** в виде тела с кодом состояния HTTP **200 OK** по умолчанию.
* **post**: этот метод извлекает пары ключ-значение, полученные в теле **JSON**, создает новый экземпляр сообщения и сохраняет его в базе данных. Если указанное имя категории существует, используется существующая категория. В противном случае метод создает новый экземпляр категории и связывает новое сообщение с этой новой категорией. Во-первых, код вызывает метод `request.get_json` для получения пар ключ-значение, полученных в качестве аргументов запроса. Затем код вызывает метод `message_schema.validate` для проверки нового сообщения, созданного с использованием полученных пар ключ-значение. Помните, что класс **MessageSchema** выполнит _ранее объясненный метод_ **process\_category** до того, как мы вызовем метод проверки, и, следовательно, данные будут обработаны до того, как произойдет проверка. В случае ошибок проверки код возвращает ошибки проверки и статус HTTP **400 Bad Request**. Если проверка прошла успешно, код извлекает имя категории, полученное в теле **JSON**, в частности, в значении ключа `'name'` ключа `'category'`. Затем код вызывает метод `Category.query.filter_by` для получения категории, которая соответствует полученному имени категории. Если совпадений не найдено, код создает новую категорию с извлеченным именем и сохраняет в базе данных. Затем код создает новое сообщение с сообщением, длительностью и соответствующим экземпляром категории и сохраняет его в базе данных. Наконец, код возвращает сериализованное сохраненное сообщение в формате **JSON** в качестве тела с кодом состояния HTTP **201 Created**.

Теперь мы создадим класс **CategoryResource**, который будем использовать для представления ресурса категории. Откройте ранее созданный файл `api/views.py` и добавьте следующие строки. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
class CategoryResource(Resource):
    def get(self, id):
        category = Category.query.get_or_404(id)
        result = category_schema.dump(category).data
        return result

    def patch(self, id):
        category = Category.query.get_or_404(id)
        category_dict = request.get_json()
        if not category_dict:
            resp = {'message': 'No input data provided'}
            return resp, status.HTTP_400_BAD_REQUEST
        errors = category_schema.validate(category_dict)
        if errors:
            return errors, status.HTTP_400_BAD_REQUEST
        try:
            if 'name' in category_dict:
                category.name = category_dict['name']
            category.update()
            return self.get(id)
        except SQLAlchemyError as e:
            db.session.rollback()
            resp = jsonify({"error": str(e)})
            return resp, status.HTTP_400_BAD_REQUEST

    def delete(self, id):
        category = Category.query.get_or_404(id)
        try:
            category.delete(category)
            response = make_response()
            return response, status.HTTP_204_NO_CONTENT
        except SQLAlchemyError as e:
            db.session.rollback()
            resp = jsonify({"error": str(e)})
            return resp, status.HTTP_401_UNAUTHORIZED
```

Класс **CategoryResource** является подклассом `flask_restful.Resource` и объявляет следующие три метода, которые будут вызываться при поступлении одноименного HTTP-метода в качестве запроса на представленный ресурс:

* **get**: этот метод получает идентификатор категории, который необходимо получить в аргументе идентификатора **id**. Код вызывает метод `Category.query.get_or_404`, чтобы вернуть статус HTTP **404 Not Found**, если в базовой базе данных нет категории с запрошенным идентификатором. Если сообщение существует, код вызывает метод `category_schema.dump` с полученной категорией в качестве аргумента, чтобы использовать экземпляр **CategorySchema** для сериализации экземпляра **Category**, идентификатор которого соответствует указанному идентификатору. Метод дампа принимает экземпляр категории и применяет фильтрацию полей и форматирование вывода, указанные в классе **CategorySchema**. Код возвращает атрибут данных результата, возвращенного методом дампа, то есть сериализованное сообщение в формате **JSON** в качестве тела с кодом состояния HTTP **200 OK** по умолчанию.
* **patch**: этот метод получает идентификатор категории, которая должна быть обновлена ​​или исправлена, в аргументе **id**. Код вызывает метод `Category.query.get_or_404`, чтобы вернуть статус HTTP **404 Not Found**, если в базовой базе данных нет категории с запрошенным идентификатором. Если категория существует, код вызывает метод `request.get_json` для получения пар ключ-значение, полученных в качестве аргументов запроса. Код обновляет только атрибут **name**, если он имеет новое значение в словаре **category\_dict** в экземпляре **Category**: **category**. Затем код вызывает метод `category_schema.validate` для получения любых ошибок, возникших при проверке обновленной категории. В случае ошибок проверки код возвращает ошибки проверки и статус HTTP **400 Bad Request**. Если проверка прошла успешно, код вызывает метод обновления для экземпляра категории, чтобы сохранить изменения в базе данных, и возвращает результаты вызова ранее объясненного метода `self.get` с идентификатором обновленной категории в качестве аргумента. Таким образом, метод возвращает сериализованное обновленное сообщение в формате **JSON** в качестве тела с кодом состояния HTTP **200 OK** по умолчанию.
* **delete**: этот метод получает идентификатор категории, которую необходимо удалить, в аргументе идентификатора. Код вызывает метод `Category.query.get_or_404`, чтобы вернуть статус HTTP **404 Not Found**, если в базовой базе данных нет категории с запрошенным идентификатором. Если категория существует, код вызывает метод `category.delete` с извлеченной категорией в качестве аргумента, чтобы использовать экземпляр категории для удаления самого себя из базы данных. Затем код возвращает пустое тело ответа и код состояния **204 No Content**.

Теперь мы создадим класс **CategoryListResource**, который будем использовать для представления коллекции категорий. Откройте ранее созданный файл `api/views.py` и добавьте следующие строки. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
class CategoryListResource(Resource):
    def get(self):
        categories = Category.query.all()
        results = category_schema.dump(categories, many=True).data
        return results

    def post(self):
        request_dict = request.get_json()
        if not request_dict:
            resp = {'message': 'No input data provided'}
            return resp, status.HTTP_400_BAD_REQUEST
        errors = category_schema.validate(request_dict)
        if errors:
            return errors, status.HTTP_400_BAD_REQUEST
        try:
            category = Category(request_dict['name'])
            category.add(category)
            query = Category.query.get(category.id)
            result = category_schema.dump(query).data
            return result, status.HTTP_201_CREATED
        except SQLAlchemyError as e:
            db.session.rollback()
            resp = jsonify({"error": str(e)})
            return resp, status.HTTP_400_BAD_REQUEST
```

Класс **CategoryListResource** является подклассом `flask_restful.Resource` и объявляет следующие два метода, которые будут вызываться при поступлении HTTP-метода с тем же именем в качестве запроса на представленный ресурс:

* **get**: этот метод возвращает список со всеми экземплярами категории, сохраненными в базе данных. Во-первых, код вызывает метод `Category.query.all` для извлечения всех экземпляров категории, сохраненных в базе данных. Затем код вызывает метод `category_schema.dump` с извлеченными сообщениями и аргументом **many**, для которого задано значение `True`, чтобы сериализовать итерируемую коллекцию объектов. Метод дампа возьмет каждый экземпляр категории, полученный из базы данных, и применит фильтрацию полей и форматирование вывода, указанные в классе **CategorySchema**. Код возвращает атрибут **data** результата, возвращенного методом дампа, то есть сериализованные сообщения в формате **JSON** в качестве тела с кодом состояния HTTP **200 OK** по умолчанию.
* **post**: этот метод извлекает пары ключ-значение, полученные в теле **JSON**, создает новый экземпляр категории и сохраняет его в базе данных. Во-первых, код вызывает метод `request.get_json` для получения пар ключ-значение, полученных в качестве аргументов запроса. Затем код вызывает метод `category_schema.validate` для проверки новой категории, созданной с использованием полученных пар ключ-значение. В случае ошибок проверки код возвращает ошибки проверки и статус HTTP **400 Bad Request**. Если проверка прошла успешно, код создает новую категорию с указанным именем и сохраняет ее в базе данных. Наконец, код возвращает сериализованную сохраненную категорию в формате JSON в качестве тела с кодом состояния HTTP **201 Created**.

В следующей таблице показан метод наших ранее созданных классов, который мы хотим выполнить для каждой комбинации HTTP-запроса и области видимости:

| HTTP запрос | Область видимости   | Класс и метод             |
| ----------- | ------------------- | ------------------------- |
| GET         | Коллекция сообщений | MessageListResource.get   |
| GET         | Сообщение           | MessageResource.get       |
| POST        | Коллекция сообщений | MessageListResource.post  |
| PATCH       | Сообщение           | MessageResource.patch     |
| DELETE      | Сообщение           | MessageResource.delete    |
| GET         | Коллекция категорий | CategoryListResource.get  |
| GET         | Сообщение           | CategoryResource.get      |
| POST        | Коллекция сообщений | CategoryListResource.post |
| PATCH       | Сообщение           | CategoryResource.patch    |
| DELETE      | Сообщение           | CategoryResource.delete   |

Если запрос приводит к вызову ресурса с неподдерживаемым методом HTTP, **Flask-RESTful** вернет ответ с кодом состояния HTTP **405 Method Not Allowed**.

Мы должны выполнить необходимые настройки маршрутизации ресурсов, чтобы вызвать соответствующие методы и передать им все необходимые аргументы, определив правила URL. Следующие строки настраивают маршрутизацию ресурсов для API. Откройте созданный ранее файл `api/views.py` и добавьте следующие строки. Файл кода для примера включен в папка `restful_python_chapter_06_01`:

```python
api.add_resource(CategoryListResource, '/categories/')
api.add_resource(CategoryResource, '/categories/<int:id>')
api.add_resource(MessageListResource, '/messages/')
api.add_resource(MessageResource, '/messages/<int:id>')
```

Каждый вызов метода `api.add_resource` направляет URL-адрес к ресурсу, в частности к одному из ранее объявленных подклассов класса `flask_restful.Resource`. Когда есть запрос к API и URL-адрес соответствует одному из URL-адресов, указанных в методе `api.add_resource`, Flask вызовет метод, который соответствует глаголу HTTP в запросе для указанного класса.

## Регистрация схемы blueprint и запуск миграции

Создайте новый файл **app.py** в папке **api**. В следующих строках показан код, создающий приложение **Flask**. Файл кода для примера включен в папку `restful_python_chapter_06_01`.

```python
from flask import Flask

def create_app(config_filename):
    app = Flask(__name__)
    app.config.from_object(config_filename)

    from models import db
    db.init_app(app)

    from views import api_bp
    app.register_blueprint(api_bp, url_prefix='/api')

    return app
```

Код в файле `api/app.py` объявляет функцию **create\_app**, которая получает имя файла конфигурации в аргументе **config\_filename**, настраивает приложение Flask с помощью этого файла конфигурации и возвращает объект приложения. Во-первых, функция создает основную точку входа для приложения Flask с именем **app**. Затем код вызывает метод `app.config.from_object` с **config\_filename**, полученным в качестве аргумента. Таким образом, приложение Flask использует значения, указанные в переменных, определенных в модуле Python, полученном в качестве аргумента, для настройки параметров приложения **Flask**.

Следующая строка вызывает метод **init\_app** для экземпляра `flask_sqlalchemy.SQLAlchemy`, созданного в модуле моделей с именем **db**. Код передает **app** в качестве аргумента, чтобы связать созданное приложение **Flask** с экземпляром **SQLAlchemy**.

Следующая строка вызывает метод `app.register_blueprint` для регистрации схемы, созданной в модуле представлений, с именем **api\_bp**. Аргумент **url\_prefix** имеет значение `'/api',` потому что мы хотим, чтобы ресурсы были доступны с префиксом `/api`. Теперь `http://localhost:5000/api/` будет URL-адресом API, работающего на сервере разработки **Flask**. Наконец, функция возвращает объект приложения **app**.

Создайте новый файл **run.py** в папке **api**. В следующих строках показан код, который использует ранее определенную функцию **create\_app** для создания приложения Flask и его запуска. Файл кода для примера включен в папку `restful_python_chapter_06_01`.

```python
from app import create_app

app = create_app('config')

if __name__ == '__main__':
    app.run(host=app.config['HOST'],
        port=app.config['PORT'],
        debug=app.config['DEBUG'])
```

Код в файле `api/run.py` вызывает функцию **create\_app**, объявленную в модуле приложения, с параметром **config**. Функция настроит приложение Flask с этим модулем в качестве файла конфигурации.

Последняя строка просто вызывает метод `app.run` для запуска приложения Flask с хостом, портом и значениями отладки, считанными из модуля **config**. Код запускает приложение, вызывая метод **run** для немедленного запуска локального сервера. Помните, что мы могли бы достичь той же цели, используя сценарий командной строки **flask**.

Создайте новый файл **migrate.py** в папке **api**. В следующих строках показан код, использующий **flask\_script** и **flask\_migrate** для выполнения миграций. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
from flask_script import Manager
from flask_migrate import Migrate, MigrateCommand
from models import db
from run import app

migrate = Migrate(app, db)
manager = Manager(app)
manager.add_command('db', MigrateCommand)

if __name__ == '__main__':
    manager.run()
```

Код создает экземпляр `flask_migrate.Migrate` с приложением **Flask**, созданным в ранее объясненном модуле запуска, **app**, и экземпляром `flask_sqlalchemy.SQLAlchemy`, созданным в модуле **models**, **db**. Затем код создает класс `flask_script.Manager` с приложением Flask в качестве аргумента и сохраняет его ссылку в переменной менеджера. Следующая строка вызывает метод **add\_command** с параметрами **db** и **MigrateCommand**. Основная функция вызывает метод запуска для экземпляра **Manager**.

Таким образом, после инициализации расширения код добавляет группу **db** к параметрам командной строки. Группа **db** имеет множество подкоманд, которые мы будем использовать в сценарии **migrate.py**.

Теперь мы запустим скрипты для выполнения миграций и создания необходимых таблиц в базе данных **PostgreSQL**. Убедитесь, что вы запускаете сценарии в терминале или в окне командной строки, в котором вы активировали виртуальную среду, и что вы находитесь в папке **api**.

Запустите первый скрипт, который инициализирует поддержку миграции для приложения.

```bash
python migrate.py db init
```

В следующих строках показан образец вывода, сгенерированный после запуска предыдущего скрипта. Ваш вывод будет отличаться в зависимости от базовой папки, в которой вы создали виртуальную среду:

```bash
Creating directory /Users/gaston/PythonREST/Flask02/api/migrations ... done
Creating directory /Users/gaston/PythonREST/Flask02/api/migrations/versions
... done
Generating /Users/gaston/PythonREST/Flask02/api/migrations/alembic.ini ...
done
Generating /Users/gaston/PythonREST/Flask02/api/migrations/env.py ... done
Generating /Users/gaston/PythonREST/Flask02/api/migrations/README ... done
Generating /Users/gaston/PythonREST/Flask02/api/migrations/script.py.mako ...
done
Please edit configuration/connection/logging settings in
'/Users/gaston/PythonREST/Flask02/api/migrations/alembic.ini' before
proceeding.
```

Сценарий создал новую подпапку **migrations** в папке **api** с подпапкой **versions** и многими другими файлами.

Запустите второй скрипт, который заполнит скрипт миграции обнаруженными изменениями в моделях. В этом случае мы впервые заполняем сценарий миграции, поэтому сценарий миграции сгенерирует таблицы, в которых будут сохраняться две наши модели: **Category** и **Message**:

```bash
python migrate.py db migrate
```

В следующих строках показан образец вывода, сгенерированный после запуска предыдущего скрипта. Ваш вывод будет отличаться в зависимости от базовой папки, в которой вы создали виртуальную среду:

```bash
INFO [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO [alembic.runtime.migration] Will assume transactional DDL.
INFO [alembic.autogenerate.compare] Detected added table 'category'
INFO [alembic.autogenerate.compare] Detected added table 'message'
Generating
/Users/gaston/PythonREST/Flask02/api/migrations/versions/417543056ac3_.py ...
done
```

Вывод показывает, что файл `api/migrations/versions/417543056ac3_.py` содержит код для создания таблиц **category** и **message**. В следующих строках показан код для этого файла, который был автоматически сгенерирован на основе моделей. Обратите внимание, что имя файла в вашей конфигурации будет другим. Файл кода для примера включен в папку `restful_python_chapter_06_01`:

```python
"""empty message
Revision ID: 417543056ac3
Revises: None
Create Date: 2016-08-08 01:05:31.134631
"""

# идентификаторы ревизий, используемые Alembic.
revision = '417543056ac3'
down_revision = None

from alembic import op
import sqlalchemy as sa

def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('category',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(length=150), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('name')
    )
    op.create_table('message',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('message', sa.String(length=250), nullable=False),
        sa.Column('duration', sa.Integer(), nullable=False),
        sa.Column('creation_date', sa.TIMESTAMP(),
            server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False),
        sa.Column('category_id', sa.Integer(), nullable=False),
        sa.Column('printed_times', sa.Integer(), server_default='0',
            nullable=False),
        sa.Column('printed_once', sa.Boolean(), server_default='false',
            nullable=False),
        sa.ForeignKeyConstraint(['category_id'], ['category.id'],
            ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('message')
    )
    ### конец комманд Alembic ###

def downgrade():
    ### команды автоматически генерируются Alembic - пожалуйста, настройте! ###
    op.drop_table('message')
    op.drop_table('category')
    ### конец комманд Alembic ###
```

Код определяет две функции: **upgrade** и **downgrade**. Функция **upgrade** запускает необходимый код для создания таблиц категорий и сообщений, вызывая `alembic.op.create_table`. Функция **downgrade** версии запускает необходимый код, чтобы вернуться к предыдущей версии.

Запустите третий скрипт для обновления базы данных:

```bash
python migrate.py db upgrade
```

В следующих строках показан образец вывода, сгенерированный после запуска предыдущего скрипта:

```bash
INFO [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO [alembic.runtime.migration] Will assume transactional DDL.
INFO [alembic.runtime.migration] Running upgrade -> 417543056ac3, empty message
```

Предыдущий сценарий вызывал функцию **upgrade**, определенную в автоматически сгенерированном сценарии `api/migrations/versions/417543056ac3_.py`. Не забывайте, что в вашей конфигурации имя файла будет другим.

После того, как мы запустим предыдущие сценарии, мы можем использовать командную строку PostgreSQL или любое другое приложение, которое позволяет нам легко проверить содержимое базы данных PostgreSQL, чтобы проверить таблицы, созданные миграцией.

Выполните следующую команду, чтобы получить список сгенерированных таблиц. В случае, если используемое вами имя базы данных не является именованным как **messages**, убедитесь, что вы используете соответствующее имя базы данных.

```bash
psql --username=user_name --dbname=messages --command="\dt"
```

Следующие строки показывают вывод со всеми сгенерированными именами таблиц:

```bash
List of relations
 Schema |       Name      |  Type |   Owner
--------+-----------------+-------+-----------
 public | alembic_version | table | user_name
 public | category        | table | user_name
 public | message         | table | user_name
(3 rows)
```

**SQLAlchemy** сгенерировал таблицы, уникальные ограничения и внешние ключи на основе информации, включенной в наши модели.

* category: сохраняет модель Category.
* message: сохраняет модель Message.

Следующая команда позволит вам проверить содержимое четырех таблиц после того, как мы составим и отправим HTTP-запросы к RESTful API и выполним операции CRUD для двух таблиц. Команды предполагают, что вы используете PostgreSQL на том же компьютере, на котором вы выполняете команду:

```bash
psql --username=user_name --dbname=messages --command="SELECT * FROM category;"
psql --username=user_name --dbname=messages --command="SELECT * FROM message;"
```

{% hint style="info" %}
**СОВЕТ**

Вместо работы с утилитой командной строки **PostgreSQL** вы можете использовать инструмент с графическим интерфейсом для проверки содержимого базы данных **PostgreSQL**. Вы также используете инструменты базы данных, включенные в вашу любимую IDE, для проверки содержимого базы данных **SQLite**.
{% endhint %}

**Alembic** сгенерировала дополнительную таблицу с именем **alembic\_version**, которая сохраняет номер версии базы данных в столбце **version\_num**. Эта таблица позволяет сценариям миграции получать текущую версию базы данных и обновлять или понижать ее в зависимости от наших потребностей.

## Создание и получение связанных ресурсов

Теперь мы можем запустить скрипт `api/run.py`, который запускает разработку **Flask**. Выполните следующую команду в папке **api**.

```bash
python run.py
```

Следующие строки показывают вывод после выполнения предыдущей команды. Сервер разработки прослушивает порт `5000`.

```bash
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
* Restarting with stat
* Debugger is active!
* Debugger pin code: 198-040-402
```

Теперь мы будем использовать команду **HTTPie** или ее эквиваленты **curl** для составления и отправки HTTP-запросов к API. Мы будем использовать JSON для запросов, требующих дополнительных данных. Помните, что вы можете выполнять те же задачи с помощью своего любимого инструмента на основе графического интерфейса.

Сначала мы составим и отправим HTTP-запросы для создания двух категорий сообщений:

```bash
http POST :5000/api/categories/ name='Information'
http POST :5000/api/categories/ name='Warning'
```

Ниже приведены эквивалентные команды **curl**:

```bash
curl -iX POST -H "Content-Type: application/json" -d '{"name":"Information"}'
:5000/api/categories/
curl -iX POST -H "Content-Type: application/json" -d '{"name":"Warning"}'
:5000/api/categories/
```

Предыдущие команды составят и отправят два HTTP-запроса **POST** с указанной парой ключ-значение **JSON**. В запросах указывается `/api/categories/`, поэтому они будут соответствовать префиксу `'/api'url_prefix` для схемы **api\_bp**. Затем запрос будет соответствовать URL-маршруту `'/categories/'` для ресурса **CategoryList** и запускать метод `CategoryList.post`. Метод не получает аргументов, так как URL-маршрут не содержит никаких параметров. Поскольку HTTP-глагол для запроса — **POST**, Flask вызывает метод **post**. Если два новых экземпляра категории были успешно сохранены в базе данных, два вызова вернут код состояния HTTP **201 Created** и недавно сохраненную категорию, сериализованную в **JSON** в теле ответа. В следующих строках показан пример ответа для двух HTTP-запросов с новыми объектами категории в ответах **JSON**.

Обратите внимание, что ответы включают URL-адрес созданных категорий. Массив **messages** пуст в обоих случаях, потому что еще нет сообщений, относящихся к каждой новой категории:

```http
HTTP/1.0 201 CREATED
Content-Length: 116
Content-Type: application/json
Date: Mon, 08 Aug 2016 05:26:58 GMT
Server: Werkzeug/0.11.10 Python/3.5.1
{
    "id": 1,
    "messages": [],
    "name": "Information",
    "url": "http://localhost:5000/api/categories/1"
}
HTTP/1.0 201 CREATED
Content-Length: 112
Content-Type: application/json
Date: Mon, 08 Aug 2016 05:27:05 GMT
Server: Werkzeug/0.11.10 Python/3.5.1
{
    "id": 2,
    "messages": [],
    "name": "Warning",
    "url": "http://localhost:5000/api/categories/2"
}
```

Теперь мы создадим и отправим HTTP-запросы для создания двух сообщений, принадлежащих первой категории сообщений, которую мы недавно создали: **Information**. Мы укажем ключ **category** с названием нужной категории сообщений. Таблица базы данных, в которой сохраняется модель **Message**, сохранит значение первичного ключа связанной **Category**, значение имени которой соответствует предоставленному нами:

```bash
http POST :5000/api/messages/ message='Checking temperature sensor' duration=5
category="Information"
http POST :5000/api/messages/ message='Checking light sensor' duration=8
category="Information"
```

Ниже приведены эквивалентные команды **curl**:

```bash
curl -iX POST -H "Content-Type: application/json" -d '{"message":" Checking
temperature sensor", "category":"Information"}' :5000/api/messages/
curl -iX POST -H "Content-Type: application/json" -d '{"message":" Checking
light sensor", "category":"Information"}' :5000/api/messages/
```

Первая команда создаст и отправит следующий HTTP-запрос: **POST** `http://localhost:5000/api/messages/` со следующими парами ключ-значение **JSON**:

```json
{
    "message": "Checking temperature sensor",
    "category": "Information"
}
```

Вторая команда создаст и отправит тот же HTTP-запрос со следующими парами ключ-значение **JSON**:

```json
{
    "message": "Checking light sensor",
    "category": "Information"
}
```

В запросах указывается `/api/categories/`, поэтому они будут соответствовать префиксу `'/api'url_prefix` для схемы **api\_bp**. Затем запрос будет соответствовать URL-маршруту '/messages/' для ресурса **MessageList** и запустить метод `MessageList.post`. Метод не получает аргументов, так как URL-маршрут не содержит никаких параметров. Поскольку HTTP-глагол для запроса — **POST**, Flask вызывает метод **post**. Метод `MessageSchema.process_category` будет обрабатывать данные для категории, а метод `MessageListResource.post` извлечет из базы данных категорию, соответствующую указанному имени категории, чтобы использовать ее в качестве связанной категории для нового сообщения. Если два новых экземпляра **Message** были успешно сохранены в базе данных, два вызова вернут код состояния HTTP **201 Created** и недавно сохраненное сообщение, сериализованное в JSON в теле ответа. В следующих строках показан пример ответа для двух HTTP-запросов с новыми объектами **Message** в ответах **JSON**. Обратите внимание, что ответы включают URL-адрес, **url**, для созданных сообщений. Кроме того, ответ включает идентификатор **id**, имя **name** и URL-адрес **url** соответствующей категории.

```http
HTTP/1.0 201 CREATED
Content-Length: 369
Content-Type: application/json
Date: Mon, 08 Aug 2016 15:18:43 GMT
Server: Werkzeug/0.11.10 Python/3.5.1
{
    "category": {
        "id": 1,
        "name": "Information",
        "url": "http://localhost:5000/api/categories/1"
    },
    "creation_date": "2016-08-08T12:18:43.260474+00:00",
    "duration": 5,
    "id": 1,
    "message": "Checking temperature sensor",
    "printed_once": false,
    "printed_times": 0,
    "url": "http://localhost:5000/api/messages/1"
}
HTTP/1.0 201 CREATED
Content-Length: 363
Content-Type: application/json
Date: Mon, 08 Aug 2016 15:27:30 GMT
Server: Werkzeug/0.11.10 Python/3.5.1
{
    "category": {
        "id": 1,
        "name": "Information",
        "url": "http://localhost:5000/api/categories/1"
    },
    "creation_date": "2016-08-08T12:27:30.124511+00:00",
    "duration": 8,
    "id": 2,
    "message": "Checking light sensor",
    "printed_once": false,
    "printed_times": 0,
    "url": "http://localhost:5000/api/messages/2"
}
```

Мы можем запустить предыдущие команды, чтобы проверить содержимое таблиц, созданных миграциями в базе данных **PostgreSQL**. Мы заметим, что столбец **category\_id** для таблицы сообщений сохраняет значение первичного ключа связанной строки в таблице **category**. Класс **MessageSchema** использует экземпляр `fields.Nested` для отображения полей идентификатора **id**, URL-адреса **url** и имени **name** для соответствующей категории. На следующем снимке экрана показано содержимое категории и таблицы сообщений в базе данных PostgreSQL после выполнения HTTP-запросов:

![](../../.gitbook/assets/db\_1.png)

Теперь мы создадим и отправим HTTP-запрос для получения категории, содержащей два сообщения, то есть ресурса категории, идентификатор или первичный ключ которого равен 1. Не забудьте заменить 1 на значение первичного ключа категории, чья имя равно `'Information'` в вашей конфигурации:

```bash
http :5000/api/categories/1
```

Ниже приведена эквивалентная команда **curl**:

```bash
curl -iX GET :5000/api/categories/1
```

Предыдущая команда создаст и отправит HTTP-запрос **GET**. Запрос имеет номер после `/api/categories/`, поэтому он будет соответствовать `'/categories/<int>:id'` и запускать метод `CategoryResource.get`, то есть метод **get** для класса **CategoryResource**. Если экземпляр категории с указанным идентификатором существует в базе данных, вызов метода вернет код состояния HTTP **200 OK** и экземпляр категории, сериализованный в **JSON**, в теле ответа. Класс **CategorySchema** использует экземпляр `fields.Nested` для отображения всех полей для всех сообщений, связанных с категорией, за исключением поля category. В следующих строках показан пример ответа:

```python
HTTP/1.0 200 OK
Content-Length: 1078
Content-Type: application/json
Date: Mon, 08 Aug 2016 16:09:10 GMT
Server: Werkzeug/0.11.10 Python/3.5.1
{
    "id": 1,
    "messages": [
        {
            "category": {
                "id": 1,
                "name": "Information",
                "url": "http://localhost:5000/api/categories/1"
            },
            "creation_date": "2016-08-08T12:27:30.124511+00:00",
            "duration": 8,
            "id": 2,
            "message": "Checking light sensor",
            "printed_once": false,
            "printed_times": 0,
            "url": "http://localhost:5000/api/messages/2"
        },
        {
            "category": {
                "id": 1,
                "name": "Information",
                "url": "http://localhost:5000/api/categories/1"
            },
            "creation_date": "2016-08-08T12:18:43.260474+00:00",
            "duration": 5,
            "id": 1,
            "message": "Checking temperature sensor",
            "printed_once": false,
            "printed_times": 0,
            "url": "http://localhost:5000/api/messages/1"
        }
    ],
    "name": "Information",
    "url": "http://localhost:5000/api/categories/1"
}
```

Теперь мы составим и отправим HTTP-запрос **POST**, чтобы создать сообщение, связанное с названием несуществующей категории: `'Error'`:

```bash
http POST :5000/api/messages/ message='Temperature sensor error' duration=10
category="Error"
```

Ниже приведены эквивалентные команды **curl**:

```bash
curl -iX POST -H "Content-Type: application/json" -d '{"message":"
Temperature sensor error", "category":"Error"}' :5000/api/messages/
```

Метод `CategoryListResource.post` не сможет получить экземпляр **Category**, имя которого равно указанному значению, поэтому метод создаст новую категорию, сохранит ее и будет использовать в качестве связанной категории для нового сообщения. В следующих строках показан пример ответа на HTTP-запрос с новым объектом **Message** в ответах JSON и сведениями о новом объекте **Category**, связанном с сообщением:

```http
HTTP/1.0 201 CREATED
Content-Length: 361
Content-Type: application/json
Date: Mon, 08 Aug 2016 17:20:22 GMT
Server: Werkzeug/0.11.10 Python/3.5.1
{
    "category": {
        "id": 3,
        "name": "Error",
        "url": "http://localhost:5000/api/categories/3"
    },
    "creation_date": "2016-08-08T14:20:22.103752+00:00",
    "duration": 10,
    "id": 3,
    "message": "Temperature sensor error",
    "printed_once": false,
    "printed_times": 0,
    "url": "http://localhost:5000/api/messages/3"
}
```

Мы можем запустить описанные ранее команды, чтобы проверить содержимое таблиц, созданных миграциями в базе данных **PostgreSQL**. Мы заметим, что у нас есть новая строка в таблице категорий с недавно добавленной категорией, когда мы создали новое сообщение. На следующем снимке экрана показано содержимое таблиц **category** и **message** в базе данных PostgreSQL после выполнения HTTP-запросов:

![](../../.gitbook/assets/db\_2.png)

## Проверьте свои знания

1. **Marshmallow** - это:
   1. Облегченная библиотека для преобразования сложных типов данных в собственные типы данных Python и обратно.
   2. ORM
   3. Легкий веб-фреймворк, который заменяет Flask.
2. **SQLAlchemy** - это:
   1. Облегченная библиотека для преобразования сложных типов данных в собственные типы данных Python и обратно
   2. ORM
   3. Легкий веб-фреймворк, который заменяет Flask.
3. Декоратор `marshmallow.pre_load`:
   1. Регистрирует метод для запуска после создания любого экземпляра класса **MessageSchema**.
   2. Регистрирует метод для вызова после сериализации объекта.
   3. Регистрирует метод для вызова перед десериализацией объекта.
4. Метод **dump** для любого экземпляра подкласса **Schema**:
   1. Направляет URL-адреса к примитивам Python.
   2. Сохраняет экземпляр или коллекцию экземпляров, переданных в базу данных в качестве аргумента.
   3. Принимает экземпляр или набор экземпляров, переданных в качестве аргумента, и применяет фильтрацию полей и форматирование вывода, указанные в подклассе **Schema**, к экземпляру или набору экземпляров.
5. Когда мы объявляем атрибут как экземпляр класса `marshmallow.fields.Nested`:
   1. Поле будет вкладывать одну схему **Schema** или их набор на основе значения аргумента **many**.
   2. В поле будет вложена одна **Schema**. Если мы хотим вложить коллекцию **Schema**, мы должны использовать экземпляр класса `marshmallow.fields.NestedCollection`.
   3. В поле будет вложена коллекция **Schema**. Если мы хотим вложить одну схему, мы должны использовать экземпляр класса `marshmallow.fields.NestedSingle`.

## Резюме

В этой главе мы расширили возможности предыдущей версии RESTful API, созданной в предыдущей главе. Мы использовали **SQLAlchemy** в качестве ORM для работы с базой данных **PostgreSQL**. Мы установили множество пакетов для упрощения многих общих задач, написали код для моделей и их взаимосвязей и работали со схемами для проверки, сериализации и десериализации этих моделей.

Мы объединили схемы **blueprint** с маршрутизацией ресурсов и смогли создать базу данных из моделей. Мы составили и отправили множество HTTP-запросов к нашему RESTful API и проанализировали, как каждый HTTP-запрос обрабатывался в нашем коде и как модели сохранялись в таблицах базы данных.

Теперь, когда мы создали сложный API с помощью **Flask**, **Flask-RESTful** и **SQLAlchemy**, мы воспользуемся дополнительными функциями и добавим безопасность и аутентификацию, о чем мы поговорим в следующей главе.
